# 構文仕様（プロトタイプ）

## 変数・関数

```zetsumetsu
int 🌵 x := 3;
int 🌵 y := x + 2;

int 🌺 pow := (int 🌵 a, int 🌵 b) {
	return a + b;
};

y := pow(x, y);
```

<!-- ### 非参照透過性をもつ関数

非参照透過性をもつ関数の返り値は `nondet` 型によって表され、その非参照透過性は型レベルで伝染することになります。

`nondet` 型はジェネリクスを用いて内部に任意の型の値を保持しますが、`nondet` 型の値を使用する際はあたかも中身の値を直接使用するかのように記述できます。

```zetsumetsu
nondet<int> 🌺 random := {
	// ...
};

nondet<int> 🌺 add := (int 🌵 a) {
	nondet<int> 🌵 x = random();

	// x は nondet<int> 型だが、int 型のように記述できる。
	return x + a;
};
```

---

非参照透過性をもつ値や関数の返り値は🎇マーカーで表されます。

返り値に関係しない引数は🍃マーカーで表されます。
🍃マーカーのない引数に🎇マーカーのついた値が渡された場合、その返り値にも🎇マーカーが感染します。

```zetsumetsu
🎇int 🌺 random := { };

🎇int 🌵 value = fuzz(random, 2, 4);

int 🌺 fuzz (int x, int y, int 🍃z) {
	return x * y;
};
```

### 副作用をもつ関数

副作用をもつ関数は `☄️` マーカーによって装飾されます。副作用を伝染させるため、副作用をもつ関数を呼び出す関数は同様に `☄️` マーカーによって装飾される必要があります。

```zetsumetsu
☄️ void 🌺 log := (str 🌵 a) {
	// ...
};

☄️ void 🌺 meow := {
	// 副作用をもつ関数 log を呼び出しているため、この関数も☄️マーカーによって装飾されなければなりません。
	log("meow");
};
``` -->

### 非参照透過性をもつ関数

非参照透過性をもつ（参照透過でない）とは、関数の返り値が引数によって一意に定まらないことをいいます。具体的には、ランダムな数値をもとに値を返すようなものや、呼び出し時点の時刻を返すようなものがこれに当たります。

ぜつめつスクリプトではこのような関数に `🧊` マーカーをつけ、呼び出し元に非参照透過性を伝播させます。

**`🧊` マーカーのついた関数は遅延評価されます。**
// 🧊\<int> みたいに型にする？それともマーカー？

```zetsumetsu
🧊 int 🌺 random := { };

🧊 int 🌺 puimui(int pui) := {
	int mui := random();

	return pui + mui;
}
```

## EBNF による構文定義

```ebnf
expr    ::= term { ("+" | "-") term }
term    ::= factor { ("*" | "/") factor }
factor  ::= number | "(" expr ")"
number  ::= digit { digit }
digit   ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
```
